# CPU上下文切换

多个进程没有运行, 在竞争CPU会导致系统的平均负载升高. 为什么呢?

Linux是一个多任务系统支持远大于CPU数量的进程同时运行,  这些程序并不是真正的在同时运行, 而是系统在很短的时间内, 将CPU轮流的分配给这些进程运行,导致多任务同时运行错觉.

## CPU的上下文是什么?

在每个任务运行前. CPU都要置顶任务从哪里加载. 从哪个开始运行, 系统会提前给它设置好**CPU寄存器**和**程序计数器(Program Counter, PC)**.

+ CPU寄存器  是CPU内置的容量小但速度极快的内存
+ 程序计数器  用来存储CPU正在执行的或者即将执行下一条指令的位置.
+ 虚拟内存
+ 用户栈

这些CPU运行前必须运行依赖的环境. 称为 **CPU上下文**

## CPU上下文切换是什么 ?

CPU的上下文切换:把前一个任务的CPU上下文保存起来, 然后加载新的任务的的上下到寄存器和程序计数器. 然后再跳转到程序计数器指向的新的位置运行新的任务.

## CPU上下文切换的分类 ?

根据任务的不同, CPU的上下文切换可以分为几个不同的场景: **进程上下文切换**, **线程上下文切换**, **中断上下文切换**.

### 进程上下文切换

linux按照特权等级,把进程的运行空间分为内核空间(Ring0)和用户空间(Ring3).

+ 内核空间(Ring) 具有最高全,可以直接访问所有资源
+ 用户空间(Ring) 只能访问受限资源, 不能直接访问内存等硬件设备.
  必须通过系统调用陷入内核态中才能访问特权资源

进程通过系统调用从用户态陷入内核态的CPU上下文切换: 保存CPU寄存器里面原来用户态的指令位置,然后CPU的寄存器更新为内核态指令的位置. 然后调整到内核态执行内核任务. 系统调用结束后CPU寄存器恢复原来用户态的指令位置, 然后切换到用户态空间继续运行进程. 一次系统调用发生了两次上下文切换.

系统的进程是有内核来进行管理和调度的, 进程的切换只能发生在内核态, 所以上下文不经包含了虚拟内存,栈,
全局变量等用户空间资源, 还包括了内核堆栈,寄存器等内核空间的状态.

**进程上线文切换的流程:**

1. 保存当前进程的寄存器,程序计数器(PC)
2. 保存当前进程的虚拟机内存,栈
3. 加载新进程的寄存器,程序计数器
4. 刷新新进程的虚拟内存和用户栈

保存上下文和切换上下文都需要消耗CPU, 在进程上下文切换次数较多的情况下容易导致CPU将大量时间消耗在切换上下文上,导致缩短了CPU运行运行程序的时间.

**什么时候进行切换进程?**
Linux为每个CPU都维护了一个就绪队列, 将活跃进程(正在运行和正在等待CPU)的进程按照优先级等待CPU 的时间排序, 然后选择最需要CPU的进程也就是优先级最高和等待CPU时间最长的进程来运行.

### 线程上下文切换

线程和进的区别:
**线程是调度的基本单位,而进程是资源拥有的最基本单位**.内核的任务调度,实际上的调度对象是线程,而进程给线程提供了虚拟内存, 全局变量等资源.

线程的上线文切换:

+ 前后两个线程属于不同进程, 资源不共享, 切换过程跟进程切换一样.
+ 前后两个线程属于相同的进程, 此时 虚拟内存是共享, 所以在切换时,虚拟内存这些资源的变, 只需要切换
  线程私有数据,寄存器等不共享的数据.

### 中断上下文件切换

为了响应硬件的事件, 中断处理会打断进程和正常的调度和执行,调用中断处理程序,响应设备事件. 在打断进程时需要将进程的的当前状态保存下来,在中断结束后,进程可以从原来的状态恢复运行.

中断上下文切换不涉及到进程的用户态, 所以不需要保存打断进程的用户态资源, 只要保存内核态中的数据,包括CPU寄存器,内核堆栈,硬件中断参数.

对于一个CPU,中断处理比进程进程有更高的优先级,所以中断不会和进程切换同时发生,中断会打断正常进程的调度和执行,所以中断程序一般都会尽快执行结束.

中断上下文切换也会消耗CPU, 切换次数过多也会消耗大量的CPU,严重时会降低系统的整体性能. 当中断次数过多时,需要排查是否会给系统带来严重的性能问题.

## 如何查看系统的上下文切换?

**使用vmstatus查看: **

```shell
root@server1:~# vmstat 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 6769000  85028 1008104    0    0     2     2   51   46  0  0 100  0  0
```

+ cs(context switch) 每秒上下文切换的次数
+ in(interrupt) 每秒中断次数
+ r (running or runnable) 就绪队列长度. 正在等待运行或者正在等待CPU的进程数
+ b (Blocked) 不可中断睡眠专题的进程

**使用pidstat -w 查看每个进程的详细情况:**

```shell
root@server1:~# pidstat -w 5 
Linux 5.4.0-89-generic (server1)        10/27/21        _x86_64_        (2 CPU)
10:43:05      UID       PID   cswch/s nvcswch/s  Command
10:43:10        0        10      0.20      0.00  ksoftirqd/0
10:43:10        0        11     15.00      0.00  rcu_sched
```

+ cswch/s   每秒自愿上下文切换次数
+ nvcswch/  每秒非自愿上下文切换次数
+ **自愿上下文切换: 进程无法获取到所需要资源,导致的上下文切换. 例如 I/O,内存等系统资源不足时就会发生自愿上下文切换.**

+ **非自愿上下文切换: 进程时间分配的CPU时间片已到,被系统强制调度发生的上下文切换.在大量进程在竞争CPU时就容易发生非自愿上下文切换**


**使用sysbench模拟多线程抢占CPU的情况:**
```
 sysbench --threads=10 --max-time=300 threads run
```

使用vmstat观察上下文切换情况:
```
root@server1:~# vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 7  0      0 6750864  86688 1018632    0    0     2     3   51  117  0  0 100  0  0
 8  0      0 6750864  86688 1018632    0    0     0     0 4425 1012166 12 88  0  0  0
 6  0      0 6750864  86688 1018632    0    0     0     0 4331 1046408 14 86  0  0  0
 7  0      0 6750864  86688 1018632    0    0     0     0 4126 1054593 14 86  0  0  0
```

使用sysbench进行模拟多线程抢占后:

+ r列 就绪队列长度从之前的0增加到8. 
+ us列,和sy列 CPU使用率加起来达到100% , 其中主要是是sy列, CPU主要被内核占用
+ in 列,  中断次数上升很多, 说明中断处理也有问题.

**使用pidstat 查看CPU和进程的上下文切换情况:**
```
root@server1:~# pidstat -w -u  1
Average:      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Average:        0      9600    0.00    0.50    0.00    0.00    0.50     -  sshd
Average:        0      9716   22.39  176.12    0.00    0.00  198.51     -  sysbench
Average:        0      9729    0.00    0.50    0.00    0.00    0.50     -  pidstat

Average:      UID       PID   cswch/s nvcswch/s  Command
Average:        0        11     21.39      0.00  rcu_sched
Average:        0        12      0.50      0.00  migration/0
Average:        0        17      0.50      0.00  migration/1
Average:        0        18      1.99      0.00  ksoftirqd/1
```

从pidstat的结果看CPU使用率升高是sysbench导致的. 

使用-t参数查看线程的上下文切换. 
```
pidstat -wt 1
Average:      UID      TGID       TID   cswch/s nvcswch/s  Command
Average:        0         -      9717  16038.35  81786.36  |__sysbench
Average:        0         -      9718  18158.24  81547.02  |__sysbench
Average:        0         -      9719  17412.50  85845.60  |__sysbench
Average:        0         -      9720  18584.80  81749.57  |__sysbench
Average:        0         -      9721  16505.82  84229.12  |__sysbench
Average:        0         -      9722  17350.71  83293.47  |__sysbench
Average:        0         -      9723  17713.07  80621.59  |__sysbench
Average:        0         -      9724  18928.27  80423.86  |__sysbench
Average:        0         -      9725  18725.99  80617.33  |__sysbench
Average:        0         -      9726  17618.04  84401.56  |__sysbench
```

**查看中断次数:**

中断次数在文件 `/proc/interrupts`中, 读取这个文件就能查看中断次数变化.
```
watch -d cat /etc/interrupts
```
从结果看 RES 列变化速度最快. 

> RES中断:  唤醒空闲状态的CPU来调度新的任务运行. 用来分散任务到不同的CPU上的机制.


根据上下文切换的类型分析:
+ 自愿上下文切换多了, 说明进程在等待资源, 可能等待I/O导致的 
+ 非自愿上下文切换变多了, 说明进程在被强制调度, 都在争抢CPU 说明CPU成了瓶颈
+ 中断次数多了, 说明CPU被中断程序占用, 需要通过查看 /proc/interrupts 文件来分析具体的类型.


分析系统问题的思路:
+ 先通过uptime查看系统的平均负载
+ 再使用mpstat和pidstat 确定是CPU还是IO导致系统平均负载升高
